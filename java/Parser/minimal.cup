package Parser;

import java_cup.runtime.*;
import AST.*;
import AST.cond.*;
import AST.exp.*;
import AST.lvar.*;
import AST.sent.*;
import AST.sentsimp.*;
import AST.vdef.*;

parser code {:
	public static void main(String args[]) throws Exception {
		new parser(new Lexer.Yylex(System.in)).parse();
	}
:}

terminal IF, THEN, ELSE, END, WHILE, PLOT, DO, NOT, AND, OR, SIZE, PROG,
INT2REAL, REAL2INT, VARS, SENO, COSENO, EXPONENCIAL, PC, ASOP, MENORQUE,
MAYORQUE, MAS, DIV, POR, PAREN, TESIS, IGUALQUE, COMA, MENOS, COLOR;

terminal Integer CENT, TIPO;
terminal Boolean CLOG;
terminal String IDENT;
terminal Double CREAL, PI;

non terminal Prog Prog;
non terminal VDef VDef;
non terminal Vars Vars;
non terminal Decl Decl;
non terminal Size Size;
non terminal LVar LVar;
non terminal Inp Inp;
non terminal Sent Sent;
non terminal SentSimp SentSimp;
non terminal Asign Asign;
non terminal Cond Cond;
non terminal Repet Repet;
non terminal Plot Plot;
non terminal Exp Exp;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence right IGUALQUE;
precedence right MAYORQUE;
precedence right MENORQUE;
precedence left MAS;
precedence left MENOS;
precedence left POR;
precedence left DIV;

start with Prog;

Prog ::= PROG IDENT:id Inp:inp Vars:vars Size:size Sent:sent {:RESULT = new Prog1(id, inp, vars, size, sent); :}; 

Inp ::= PAREN LVar:lvar TESIS {:RESULT = new Inp1(lvar); :}; 

Vars ::= VARS VDef:vdef {:RESULT = new Vars1(vdef); :}; 

VDef ::= Decl:decl PC {:RESULT = new VDef1(decl); :}
		| Decl:decl PC VDef:vdef {:RESULT = new VDef2(decl, vdef); :};

Decl ::= TIPO LVar:lvar {:RESULT = new Decl1(lvar); :};

LVar ::= IDENT:id {:RESULT = new LVar1(id); :}
		| IDENT:id COMA LVar:lvar {:RESULT = new LVar2(id, lvar); :};

Size ::= SIZE PAREN Exp:exp1 COMA Exp:exp2 TESIS PC {:RESULT = new Size1(exp1, exp2); :}; 

Sent ::= SentSimp:sentsimp PC Sent:sent {:RESULT = new Sent1(sentsimp, sent); :}
		| SentSimp:sentsimp PC {:RESULT = new Sent2(sentsimp); :};

SentSimp ::= Asign:asign {:RESULT = new SentSimp1(asign); :}
		| Cond:cond {:RESULT = new SentSimp2(cond); :}
		| Repet:repet {:RESULT = new SentSimp3(repet); :}
		| Plot:plot {:RESULT = new SentSimp4(plot); :};

Asign ::= IDENT:id ASOP Exp:exp {:RESULT = new Asign1(id, exp); :};

Cond ::= IF Exp:exp THEN Sent:sent END{:RESULT = new Cond1(exp, sent); :}
		|IF Exp:exp THEN Sent:sent1 ELSE Sent:sent2 END{:RESULT = new Cond2(exp, sent1, sent2); :};

Repet ::= WHILE Exp:exp DO Sent:sent END{:RESULT = new Repet1(exp, sent); :};

Plot ::= PLOT PAREN COLOR COMA Exp:exp1 COMA Exp:exp2 TESIS{:RESULT = new Plot1(exp1, exp2); :};

Exp::= CLOG:clog                        {:RESULT=new E_ConstanteBooleana(clog); :}
      	|   Exp:e1 AND Exp:e2	            {:RESULT=new E_And(e1, e2); :}
      	|   Exp:e1 OR Exp:e2	            {:RESULT=new E_Or(e1, e2); :}
      	|   NOT Exp:e1              	    {:RESULT=new E_Not(e1); :}
      	|   Exp:e1 IGUALQUE Exp:e2	    {:RESULT=new E_IgualQue(e1, e2); :}
      	|   Exp:e1 MAYORQUE Exp:e2        {:RESULT=new E_MayorQue(e1, e2); :}
      	|   Exp:e1 MENORQUE Exp:e2	    {:RESULT=new E_MenorQue(e1, e2); :}

      	|   IDENT:i1                      {:RESULT=new E_Ident(i1); :}
      	|   PAREN Exp:e1 TESIS            {:RESULT=new E_Parentesis(e1); :}

      	|   CENT:n                        {:RESULT=new E_ConstanteEntera(n); :}
      	|   Exp:e1 MAS Exp:e2	            {:RESULT=new E_Mas(e1, e2); :}
      	|   Exp:e1 MENOS Exp:e2           {:RESULT=new E_Menos(e1, e2); :}
      	|   Exp:e1 POR Exp:e2  	        {:RESULT=new E_Por(e1, e2); :}
      	|   Exp:e1 DIV Exp:e2	            {:RESULT=new E_Div(e1, e2); :}
      	|   MENOS Exp:e1              	{:RESULT=new E_Opuesto(e1); :}
		|   CREAL:creal                        {:RESULT=new E_ConstanteReal(creal); :}
		|	REAL2INT PAREN Exp:exp TESIS {:RESULT = new Real2Int(exp); :}
		| 	INT2REAL PAREN Exp:exp TESIS {:RESULT = new Int2Real(exp); :}
		| 	SENO PAREN Exp:exp TESIS {:RESULT = new Seno(exp); :}
		| 	COSENO PAREN Exp:exp TESIS {:RESULT = new Coseno(exp); :}
		| 	EXPONENCIAL PAREN Exp:exp TESIS {:RESULT = new Exponencial(exp); :};

